<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Automating Postgres Deployment with Docker Compose and Init Scripts | ExitCode0</title>
<meta name=keywords content="docker,compose,bash,IAC,postgres"><meta name=description content="Introduction to Running PostgreSQL in a Docker Container using Docker Compose
In this blog post, we will explore how to run PostgreSQL in a Docker container using Docker Compose. We will also break down and explain the init-user-db.sh script that is executed at startup to initialize the PostgreSQL tables. Running PostgreSQL in a Docker container provides several benefits, including ease of deployment, portability, and isolation. So let&rsquo;s dive in and understand the process!"><meta name=author content="Tom"><link rel=canonical href=https://exitcode0.net/posts/automating-postgres-deployment/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://exitcode0.net/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://exitcode0.net/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://exitcode0.net/favicon-32x32.png><link rel=apple-touch-icon href=https://exitcode0.net/apple-touch-icon.png><link rel=mask-icon href=https://exitcode0.net/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://exitcode0.net/posts/automating-postgres-deployment/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7745507566538945" crossorigin=anonymous></script><script data-name=BMC-Widget data-cfasync=false src=https://cdnjs.buymeacoffee.com/1.0.0/widget.prod.min.js data-id=exit data-description="Support me on Buy me a coffee!" data-message="Buy me a coffee" data-color=#FF813F data-position=Right data-x_margin=18 data-y_margin=165></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-EDE9MPZR9T"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-EDE9MPZR9T")}</script><meta property="og:title" content="Automating Postgres Deployment with Docker Compose and Init Scripts"><meta property="og:description" content="Introduction to Running PostgreSQL in a Docker Container using Docker Compose
In this blog post, we will explore how to run PostgreSQL in a Docker container using Docker Compose. We will also break down and explain the init-user-db.sh script that is executed at startup to initialize the PostgreSQL tables. Running PostgreSQL in a Docker container provides several benefits, including ease of deployment, portability, and isolation. So let&rsquo;s dive in and understand the process!"><meta property="og:type" content="article"><meta property="og:url" content="https://exitcode0.net/posts/automating-postgres-deployment/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-01-06T12:00:00+01:00"><meta property="article:modified_time" content="2024-01-06T12:00:00+01:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Automating Postgres Deployment with Docker Compose and Init Scripts"><meta name=twitter:description content="Introduction to Running PostgreSQL in a Docker Container using Docker Compose
In this blog post, we will explore how to run PostgreSQL in a Docker container using Docker Compose. We will also break down and explain the init-user-db.sh script that is executed at startup to initialize the PostgreSQL tables. Running PostgreSQL in a Docker container provides several benefits, including ease of deployment, portability, and isolation. So let&rsquo;s dive in and understand the process!"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://exitcode0.net/posts/"},{"@type":"ListItem","position":2,"name":"Automating Postgres Deployment with Docker Compose and Init Scripts","item":"https://exitcode0.net/posts/automating-postgres-deployment/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Automating Postgres Deployment with Docker Compose and Init Scripts","name":"Automating Postgres Deployment with Docker Compose and Init Scripts","description":"Introduction to Running PostgreSQL in a Docker Container using Docker Compose In this blog post, we will explore how to run PostgreSQL in a Docker container using Docker Compose. We will also break down and explain the init-user-db.sh script that is executed at startup to initialize the PostgreSQL tables. Running PostgreSQL in a Docker container provides several benefits, including ease of deployment, portability, and isolation. So let\u0026rsquo;s dive in and understand the process!\n","keywords":["docker","compose","bash","IAC","postgres"],"articleBody":"Introduction to Running PostgreSQL in a Docker Container using Docker Compose In this blog post, we will explore how to run PostgreSQL in a Docker container using Docker Compose. We will also break down and explain the init-user-db.sh script that is executed at startup to initialize the PostgreSQL tables. Running PostgreSQL in a Docker container provides several benefits, including ease of deployment, portability, and isolation. So let’s dive in and understand the process!\nThis post uses Docker Compose V2, if you are still using V1, consider upgrading otherwise use docker-compose instead of docker compose.\nWhy Run PostgreSQL in a Docker Container? Running PostgreSQL in a Docker container offers numerous advantages. Here are a few key benefits:\nEasy Deployment: Docker simplifies the deployment process by encapsulating PostgreSQL and its dependencies into a container, making it easy to set up and manage.\nPortability: Docker containers are self-contained and can be run on any system that supports Docker, ensuring consistent behavior across different environments.\nIsolation: Running PostgreSQL in a container provides isolation from the host system, preventing potential conflicts with existing installations or dependencies.\nSetting Up PostgreSQL in a Docker Container with Docker Compose Before we start, ensure that you have Docker and Docker Compose installed on your system. Once both are set up, you can proceed with the following steps:\nCreate a Docker Compose file: Open a text editor and create a file called docker-compose.yml. Copy and paste the following contents into the file: version: '3.3' services: postgres: container_name: my-postgres image: postgres:latest restart: always environment: POSTGRES_USER: ${POSTGRES_USER} POSTGRES_PASSWORD: ${POSTGRES_PASSWORD} POSTGRES_DB: ${POSTGRES_DB} PGDATA: /var/lib/postgresql/data/pgdata ports: - \"5432:5432\" volumes: - ./data:/var/lib/postgresql/data/pgdata - ./init-user-db.sh:/docker-entrypoint-initdb.d/init-user-db.sh In this Docker Compose configuration:\nThe postgres service is defined with the specified container name (my-postgres), the latest PostgreSQL image (postgres:latest), and the restart policy set to always to ensure that the container restarts automatically if it stops.\nThe environment section sets the PostgreSQL environment variables (POSTGRES_USER, POSTGRES_PASSWORD, POSTGRES_DB) using the provided values from the environment. In this example I have a .env file in the same directory as the docker-compose.yml file, which means that there is no need for sensitive data such as passwords to be stored in our infrastructure code. This .env file could be replaced by git secrets in part of a pipeline deployment.\nThe ports section maps the host machine’s port 5432 to the container’s port 5432, allowing you to access the PostgreSQL database from your host machine.\nThe volumes section mounts two directories:\n./data:/var/lib/postgresql/data/pgdata: This maps the ./data directory on your host machine to the /var/lib/postgresql/data/pgdata directory inside the container. It allows you to persist the PostgreSQL data files across container restarts. ./init-user-db.sh:/docker-entrypoint-initdb.d/init-user-db.sh: This mounts the init-user-db.sh script from your host machine to the /docker-entrypoint-initdb.d/init-user-db.sh path inside the container. This script will be executed during container startup to initialize the PostgreSQL tables. Start the PostgreSQL container: Open your terminal or command prompt, navigate to the directory containing the docker-compose.yml file, and run the following command: docker compose up -d The -d flag runs the containers in detached mode, allowing\nthem to run in the background.\nBreaking Down the init-user-db.sh Script The init-user-db.sh script is executed at startup to initialize the PostgreSQL tables. Let’s examine the script and understand its purpose:\n#!/bin/bash set -e set -u export PGDATABASE=${POSTGRES_DB} export PGUSER=${POSTGRES_USER} export PGPASSWORD=${POSTGRES_PASSWORD} RUN_PSQL=\"psql -X --set AUTOCOMMIT=on --set ON_ERROR_STOP=on \" ${RUN_PSQL} \u003c","wordCount":"928","inLanguage":"en","datePublished":"2024-01-06T12:00:00+01:00","dateModified":"2024-01-06T12:00:00+01:00","author":{"@type":"Person","name":"Tom"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://exitcode0.net/posts/automating-postgres-deployment/"},"publisher":{"@type":"Organization","name":"ExitCode0","logo":{"@type":"ImageObject","url":"https://exitcode0.net/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://exitcode0.net/ accesskey=h title="ExitCode0 (Alt + H)">ExitCode0</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://datasolace.com/ title=DataSolace><span>DataSolace</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li><li><a href=https://exitcode0.net/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://exitcode0.net/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://exitcode0.net/privacy/ title=Privacy><span>Privacy</span></a></li><li><a href=https://exitcode0.net/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://exitcode0.net/>Home</a>&nbsp;»&nbsp;<a href=https://exitcode0.net/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Automating Postgres Deployment with Docker Compose and Init Scripts</h1><div class=post-meta><span title='2024-01-06 12:00:00 +0100 +0100'>January 6, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Tom</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#introduction-to-running-postgresql-in-a-docker-container-using-docker-compose aria-label="Introduction to Running PostgreSQL in a Docker Container using Docker Compose">Introduction to Running PostgreSQL in a Docker Container using Docker Compose</a></li><li><a href=#why-run-postgresql-in-a-docker-container aria-label="Why Run PostgreSQL in a Docker Container?">Why Run PostgreSQL in a Docker Container?</a><ul><li><a href=#setting-up-postgresql-in-a-docker-container-with-docker-compose aria-label="Setting Up PostgreSQL in a Docker Container with Docker Compose">Setting Up PostgreSQL in a Docker Container with Docker Compose</a></li><li><a href=#breaking-down-the-init-user-dbsh-script aria-label="Breaking Down the init-user-db.sh Script">Breaking Down the init-user-db.sh Script</a></li></ul></li><li><a href=#conclusion aria-label=Conclusion>Conclusion</a></li></ul></div></details></div><div class=post-content><h2 id=introduction-to-running-postgresql-in-a-docker-container-using-docker-compose>Introduction to Running PostgreSQL in a Docker Container using Docker Compose<a hidden class=anchor aria-hidden=true href=#introduction-to-running-postgresql-in-a-docker-container-using-docker-compose>#</a></h2><p>In this blog post, we will explore how to run <a href=https://www.postgresql.org/>PostgreSQL</a> in a Docker container using <a href=https://docs.docker.com/compose/>Docker Compose</a>. We will also break down and explain the <code>init-user-db.sh</code> script that is executed at startup to initialize the PostgreSQL tables. Running PostgreSQL in a Docker container provides several benefits, including ease of deployment, portability, and isolation. So let&rsquo;s dive in and understand the process!</p><p><img loading=lazy src=/images/postgres-on-docker.png alt="PostgreSQL in a Docker container"></p><blockquote><p>This post uses Docker Compose V2, if you are still using V1, consider upgrading otherwise use <code>docker-compose</code> instead of <code>docker compose</code>.</p></blockquote><h2 id=why-run-postgresql-in-a-docker-container>Why Run PostgreSQL in a Docker Container?<a hidden class=anchor aria-hidden=true href=#why-run-postgresql-in-a-docker-container>#</a></h2><p>Running PostgreSQL in a Docker container offers numerous advantages. Here are a few key benefits:</p><ul><li><p><strong>Easy Deployment</strong>: Docker simplifies the deployment process by encapsulating PostgreSQL and its dependencies into a container, making it easy to set up and manage.</p></li><li><p><strong>Portability</strong>: Docker containers are self-contained and can be run on any system that supports Docker, ensuring consistent behavior across different environments.</p></li><li><p><strong>Isolation</strong>: Running PostgreSQL in a container provides isolation from the host system, preventing potential conflicts with existing installations or dependencies.</p></li></ul><h3 id=setting-up-postgresql-in-a-docker-container-with-docker-compose>Setting Up PostgreSQL in a Docker Container with Docker Compose<a hidden class=anchor aria-hidden=true href=#setting-up-postgresql-in-a-docker-container-with-docker-compose>#</a></h3><p>Before we start, ensure that you have Docker and Docker Compose installed on your system. Once both are set up, you can proceed with the following steps:</p><ol><li><strong>Create a Docker Compose file</strong>: Open a text editor and create a file called <code>docker-compose.yml</code>. Copy and paste the following contents into the file:</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>version</span>: <span style=color:#e6db74>&#39;3.3&#39;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>services</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>postgres</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>container_name</span>: <span style=color:#ae81ff>my-postgres</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>image</span>: <span style=color:#ae81ff>postgres:latest</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>restart</span>: <span style=color:#ae81ff>always</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>environment</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>POSTGRES_USER</span>: <span style=color:#ae81ff>${POSTGRES_USER}</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>POSTGRES_PASSWORD</span>: <span style=color:#ae81ff>${POSTGRES_PASSWORD}</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>POSTGRES_DB</span>: <span style=color:#ae81ff>${POSTGRES_DB}</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>PGDATA</span>: <span style=color:#ae81ff>/var/lib/postgresql/data/pgdata</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>ports</span>:
</span></span><span style=display:flex><span>      - <span style=color:#e6db74>&#34;5432:5432&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>volumes</span>:
</span></span><span style=display:flex><span>      - <span style=color:#ae81ff>./data:/var/lib/postgresql/data/pgdata</span>
</span></span><span style=display:flex><span>      - <span style=color:#ae81ff>./init-user-db.sh:/docker-entrypoint-initdb.d/init-user-db.sh</span>
</span></span></code></pre></div><p>In this Docker Compose configuration:</p><ul><li><p>The <code>postgres</code> service is defined with the specified container name (<code>my-postgres</code>), the latest PostgreSQL image (<code>postgres:latest</code>), and the <code>restart</code> policy set to <code>always</code> to ensure that the container restarts automatically if it stops.</p></li><li><p>The <code>environment</code> section sets the PostgreSQL environment variables (<code>POSTGRES_USER</code>, <code>POSTGRES_PASSWORD</code>, <code>POSTGRES_DB</code>) using the provided values from the environment. In this example I have a <code>.env</code> file in the same directory as the <code>docker-compose.yml</code> file, which means that there is no need for sensitive data such as passwords to be stored in our infrastructure code. This <code>.env</code> file could be replaced by <a href=https://docs.github.com/en/actions/security-guides/encrypted-secrets>git secrets</a> in part of a pipeline deployment.</p></li><li><p>The <code>ports</code> section maps the host machine&rsquo;s port <code>5432</code> to the container&rsquo;s port <code>5432</code>, allowing you to access the PostgreSQL database from your host machine.</p></li><li><p>The <code>volumes</code> section mounts two directories:</p><ul><li><code>./data:/var/lib/postgresql/data/pgdata</code>: This maps the <code>./data</code> directory on your host machine to the <code>/var/lib/postgresql/data/pgdata</code> directory inside the container. It allows you to persist the PostgreSQL data files across container restarts.</li><li><code>./init-user-db.sh:/docker-entrypoint-initdb.d/init-user-db.sh</code>: This mounts the <code>init-user-db.sh</code> script from your host machine to the <code>/docker-entrypoint-initdb.d/init-user-db.sh</code> path inside the container. This script will be executed during container startup to initialize the PostgreSQL tables.</li></ul></li></ul><ol start=2><li><strong>Start the PostgreSQL container</strong>: Open your terminal or command prompt, navigate to the directory containing the <code>docker-compose.yml</code> file, and run the following command:</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker compose up -d
</span></span></code></pre></div><p>The <code>-d</code> flag runs the containers in detached mode, allowing</p><p>them to run in the background.</p><h3 id=breaking-down-the-init-user-dbsh-script>Breaking Down the <code>init-user-db.sh</code> Script<a hidden class=anchor aria-hidden=true href=#breaking-down-the-init-user-dbsh-script>#</a></h3><p>The <code>init-user-db.sh</code> script is executed at startup to initialize the PostgreSQL tables. Let&rsquo;s examine the script and understand its purpose:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e>#!/bin/bash
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>set -e
</span></span><span style=display:flex><span>set -u
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>export PGDATABASE<span style=color:#f92672>=</span><span style=color:#e6db74>${</span>POSTGRES_DB<span style=color:#e6db74>}</span>
</span></span><span style=display:flex><span>export PGUSER<span style=color:#f92672>=</span><span style=color:#e6db74>${</span>POSTGRES_USER<span style=color:#e6db74>}</span>
</span></span><span style=display:flex><span>export PGPASSWORD<span style=color:#f92672>=</span><span style=color:#e6db74>${</span>POSTGRES_PASSWORD<span style=color:#e6db74>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>RUN_PSQL<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;psql -X --set AUTOCOMMIT=on --set ON_ERROR_STOP=on &#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#e6db74>${</span>RUN_PSQL<span style=color:#e6db74>}</span> <span style=color:#e6db74>&lt;&lt;SQL
</span></span></span><span style=display:flex><span><span style=color:#e6db74>CREATE TABLE public.mytable
</span></span></span><span style=display:flex><span><span style=color:#e6db74>(
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    id uuid NOT NULL,
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    sensor_name text NOT NULL,
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    battery double precision,
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    humidity double precision,
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    link_quality double precision,
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    temperature double precision,
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    voltage integer,
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    &#34;time&#34; timestamp with time zone NOT NULL
</span></span></span><span style=display:flex><span><span style=color:#e6db74>)
</span></span></span><span style=display:flex><span><span style=color:#e6db74>TABLESPACE pg_default;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>ALTER TABLE IF EXISTS public.mytable
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    OWNER to dbadm;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>SQL</span>
</span></span></code></pre></div><p>Here&rsquo;s a breakdown of the script:</p><ul><li><p>The <code>set -e</code> and <code>set -u</code> commands ensure that the script exits immediately if any command fails or encounters an unset variable.</p></li><li><p>The <code>export</code> statements set environment variables to configure the PostgreSQL connection. The variables <code>PGDATABASE</code>, <code>PGUSER</code>, and <code>PGPASSWORD</code> are assigned values based on the corresponding Docker environment variables (derived from the <code>.env</code> file).</p></li><li><p>The <code>RUN_PSQL</code> variable defines the <code>psql</code> command with specific options. <code>-X</code> disables transaction management, <code>--set AUTOCOMMIT=on</code> ensures that each command is executed in its own transaction, and <code>--set ON_ERROR_STOP=on</code> stops the script execution if any error occurs.</p></li><li><p>The <code>${RUN_PSQL} &lt;&lt;SQL</code> syntax starts a here-document that allows us to provide SQL commands inline.</p></li><li><p>The SQL commands enclosed within the <code>SQL</code> delimiter create a table named <code>mytable</code> in the <code>public</code> schema with the specified columns and data types. The <code>ALTER TABLE</code> statement sets the owner of the table to <code>dbadm</code> if the table already exists.</p></li></ul><p>With this updated Docker Compose configuration, you can easily manage and deploy your PostgreSQL container along with the initialization script. Running <code>docker compose up -d</code> will start the containers and execute the <code>init-user-db.sh</code> script to initialize the PostgreSQL tables.</p><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>In this blog post, we have learned how to run PostgreSQL in a Docker container using Docker Compose. We have seen the advantages of running PostgreSQL in a container and how to set it up with the <code>docker-compose.yml</code> file. Additionally, we have explored the <code>init-user-db.sh</code> script and its role in initializing the PostgreSQL tables.</p><p>By leveraging Docker and Docker Compose, you can easily deploy and manage PostgreSQL in a portable and isolated environment. This approach brings flexibility and scalability to your PostgreSQL deployments, making it an ideal choice for various applications.</p><p>Hopefully this blog post has been helpful in understanding the process of running PostgreSQL in a Docker container using Docker Compose. Stay tuned for more exciting tutorials and guides. Consider <a href=https://bmc.link/exit>buying me a coffee</a> to feed the addiction and help me solve more automation headaches!</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://exitcode0.net/tags/docker/>Docker</a></li><li><a href=https://exitcode0.net/tags/compose/>Compose</a></li><li><a href=https://exitcode0.net/tags/bash/>Bash</a></li><li><a href=https://exitcode0.net/tags/iac/>IAC</a></li><li><a href=https://exitcode0.net/tags/postgres/>Postgres</a></li></ul><nav class=paginav><a class=prev href=https://exitcode0.net/posts/python-development-in-docker-containers/><span class=title>« Prev</span><br><span>Python Development in Docker Containers</span>
</a><a class=next href=https://exitcode0.net/posts/wyoming-piper-docker-compose/><span class=title>Next »</span><br><span>Setting up Wyoming Piper with Docker Compose</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://exitcode0.net/>ExitCode0</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>